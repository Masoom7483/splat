// Jose
// functions to calculate distance based on haat, erp, field strength

// To avoid ReferenceError: function not defined, these anonymous functions need
// to be declared OUTSIDE the $(document).ready function

//---- FM and TV Propagation Curves Data ---------------------------------------------------------------

// Distance values for F(50,50) curves
var D50 = [
  1.609344, 3.218688, 4.828032, 6.437376, 8.04672, 16.09344, 32.18688, 48.28032,
  64.37376, 80.4672, 96.56064, 112.65408, 128.74752, 144.84096, 160.9344,
  177.02784, 193.12128, 209.21472, 225.30816, 241.4016, 257.49504, 273.58848,
  289.68192, 305.77536, 321.8688, 0.0,
];

// Distance values for F(50,10) curves
// Distance of D10(31) added to smooth out the graph and interpolation
// for the F(50,10) curve at the rarely used distance of (almost) 500 km

var D10 = [
  16.09344, 32.18688, 48.28032, 64.37376, 80.4672, 96.56064, 112.65408,
  128.74752, 144.84096, 160.9344, 177.02784, 193.12128, 209.21472, 225.30816,
  241.4016, 257.49504, 273.58848, 289.68192, 305.77536, 321.8688, 337.96224,
  354.05568, 370.14912, 386.24256, 402.336, 418.42944, 434.52288, 450.61632,
  466.70976, 482.8032, 498.89644, 0.0,
];

// Height values H10, H50 in meters
var H50 = [
  30.48, 60.96, 121.92, 182.88, 243.84, 304.8, 381.0, 457.2, 533.4, 609.6,
  914.4, 1219.2, 1524.0, 0.0,
];

var H10 = [
  30.48, 60.96, 121.92, 182.88, 243.84, 304.8, 381.0, 457.2, 533.4, 609.6,
  914.4, 1219.2, 1524.0, 0.0,
];

/************************************************************************
!  F(50,50) FIELD STRENGTH DATA FOR THE LOW VHF PROPAGATION CURVE.  (FM AND TV CHANNELS 2 THROUGH 6 )  --  (13 points * 25 curves = 325)                        *
!***********************************************************************/
// was [25][13]

var F55LV = [
  92, 79.7, 72.7, 67.8, 64, 52, 39.4, 31, 25.3, 20.3, 16.2, 12.8, 9.8, 6.9, 4,
  1.5, -1.1, -3.6, -5.8, -8.1, -10.6, -13, -15.1, -17.2, -19.2, 98, 85.9, 79,
  73.8, 70, 58, 45.5, 37, 29.5, 23.5, 18.1, 14.5, 11, 8.2, 5.5, 2.9, 0.3, -2.2,
  -4.8, -7, -9.4, -11.7, -14, -16.1, -18.3, 100.6, 91, 84.8, 80, 76, 64, 51.5,
  43, 35.5, 28.8, 22, 17.1, 13.4, 10.2, 7.4, 4.8, 2.2, -0.3, -3, -5.2, -7.6,
  -10, -12.2, -14.6, -16.9, 101.5, 93.4, 87.8, 83.3, 79.6, 67.6, 55, 46.7, 39,
  32, 25.3, 19.8, 15.2, 11.8, 8.9, 6, 3.7, 1, -1.4, -3.9, -6.1, -8.7, -11,
  -13.2, -15.6, 101.9, 94.6, 89.4, 85.4, 82, 70, 57.6, 49, 41.5, 34.4, 27.7, 22,
  17, 13.1, 10.1, 7.2, 4.8, 2, -0.3, -2.7, -5.1, -7.6, -10, -12.1, -14.6, 102,
  95, 90.4, 86.8, 83.7, 72, 59.6, 51, 43.6, 36.7, 29.9, 23.9, 18.8, 14.7, 11.5,
  8.4, 5.7, 3, 0.6, -1.8, -4.2, -6.6, -9, -11.2, -13.6, 102.1, 95.6, 91.2, 87.7,
  85, 73.9, 61.7, 53.2, 45.9, 39.1, 32, 26, 21, 16.8, 13.1, 9.9, 7, 4.1, 1.7,
  -0.7, -3.2, -5.6, -8, -10.2, -12.5, 102.2, 95.9, 91.8, 88.3, 85.8, 75.4, 63.3,
  55.1, 47.9, 41.5, 34.4, 28.3, 23.2, 18.8, 14.9, 11.1, 8, 5.2, 2.7, 0.2, -2.2,
  -4.6, -7, -9.2, -11.6, 102.3, 96, 92, 88.9, 86.3, 76.7, 64.9, 57, 50, 43.5,
  36.7, 30.7, 25.2, 20.4, 16, 12.5, 9.1, 6.2, 3.8, 1.1, -1.3, -3.6, -6.1, -8.4,
  -10.6, 102.4, 96.1, 92.2, 89.2, 86.7, 77.9, 66.2, 58.5, 51.5, 45, 38.2, 32.4,
  27, 22, 17.3, 13.7, 10.1, 7.1, 4.6, 2, -0.4, -2.7, -5.1, -7.6, -10, 102.5,
  96.3, 92.5, 89.9, 87.6, 80.2, 70, 62.6, 55.4, 48.9, 42.5, 36.9, 31, 25.7, 21,
  17.1, 13.6, 10.3, 7.8, 5.1, 2.8, 0.5, -2.1, -4.5, -6.8, 102.5, 96.5, 92.5,
  90.1, 88, 81.3, 72.4, 65, 57.8, 51.2, 44.9, 39.1, 33.2, 28.1, 23.5, 19.8,
  16.1, 13, 10.4, 8, 5.5, 3.1, 0.6, -2, -4.1, 102.5, 96.5, 92.5, 90.2, 88.1,
  81.9, 74.2, 66.5, 59.6, 53, 46.4, 40.8, 35, 30, 25.5, 21.8, 18.3, 15, 12.4,
  10, 7.7, 5.1, 2.8, 0.2, -2,
];

/***********************************************************************
!  F(50,10)  FIELD STRENGTH DATA  FOR THE LOW VHF PROPAGATION CURVE.  ( FM AND TV CHANNELS 2 THROUGH 6 ) -- (13 points * 31 curves = 403)              
!**********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]

var F51LV = [
  52.2, 41.4, 36.4, 33, 30, 26.7, 23.5, 20.4, 17.4, 14.5, 11.5, 8.5, 5.9, 3,
  0.6, -2, -4.3, -6.6, -8.7, -10.5, -12.5, -14.6, -16.6, -18.6, -20.5, -22.4,
  -24.3, -26.2, -28.1, -30, -31.9, 58.4, 47, 40.9, 36, 31.9, 28, 24.9, 22, 19,
  16.1, 13.1, 10.1, 7.7, 4.9, 2, -0.4, -3, -5.1, -7.4, -9.4, -11.4, -13.4,
  -15.5, -17.4, -19.3, -21.2, -23.2, -25, -27, -29, -31, 64.3, 53, 45.9, 39.9,
  35, 30.5, 26.9, 24, 20.9, 18.2, 15.3, 12.4, 9.8, 6.9, 4.1, 1.6, -1, -3.4,
  -5.8, -8, -10.1, -12, -14.1, -16, -18, -19.9, -21.9, -23.7, -25.6, -27.4,
  -29.2, 68, 56.5, 49, 43, 37.7, 32.8, 28.8, 25.6, 22.5, 19.8, 16.9, 13.9, 11,
  8.2, 5.7, 2.9, 0.3, -2.2, -4.6, -6.9, -9, -11, -13, -15, -17, -18.9, -20.9,
  -22.5, -24.6, -26.3, -28, 70.5, 59, 51.7, 45.4, 40, 34.9, 30.4, 27, 23.9, 21,
  18.2, 15.1, 12.3, 9.7, 6.9, 4.1, 1.6, -1, -3.4, -5.7, -8, -10, -12, -14, -16,
  -17.9, -19.9, -21.7, -23.6, -25.4, -27.2, 72.3, 60.9, 53.7, 47.5, 41.9, 36.8,
  32, 28.4, 25, 22, 19.2, 16.2, 13.4, 10.7, 8, 5.3, 2.7, 0, -2.5, -4.9, -7, -9,
  -11.2, -13.2, -15.1, -17, -19, -21, -23, -24.6, -26.2, 74.2, 63, 56, 50, 44.4,
  39.2, 34.9, 30.8, 27, 23.9, 20.8, 17.8, 14.8, 12, 9.1, 6.7, 3.9, 1.1, -1.4,
  -3.9, -6, -8, -10.2, -12.2, -14.2, -16.2, -18.1, -20, -22, -23.7, -25.4, 75.9,
  64.8, 57.9, 52, 46.7, 41.6, 37.1, 33, 29, 25.5, 22, 19, 16, 13.2, 10.3, 7.9,
  5, 2.2, -0.2, -2.8, -5, -7, -9.2, -11.3, -13.3, -15.3, -17.2, -19.2, -21.1,
  -22.8, -24.5, 77, 66.2, 59.6, 54, 48.5, 43.5, 39.2, 35, 30.8, 26.9, 23.2, 20,
  17.1, 14.2, 11.6, 9, 6, 3.3, 0.9, -1.8, -4, -6.2, -8.2, -10.5, -12.5, -14.6,
  -16.3, -18.4, -20.2, -22, -23.8, 78.2, 67.6, 60.9, 55.2, 50, 45, 40.7, 36.2,
  32, 28, 24.1, 21, 18, 15.3, 12.5, 10, 7, 4.4, 1.8, -0.8, -3, -5.3, -7.4, -9.8,
  -11.8, -14, -15.8, -17.8, -19.6, -21.3, -23, 80.8, 71.2, 64.5, 58.9, 53.9, 49,
  44.2, 39.8, 35.4, 31.3, 27.6, 24.4, 21.6, 18.9, 16, 13.6, 10.7, 8, 5.2, 2.8,
  0.3, -2, -4.5, -7, -9, -11.1, -13.2, -15, -17, -19, -21, 81.8, 73.8, 67, 61.4,
  56.3, 51.7, 46.9, 42, 37.8, 33.8, 30, 27, 24.1, 21.5, 18.8, 16.1, 13.6, 10.9,
  8.1, 5.3, 3, 0.4, -1.9, -4.3, -6.7, -9, -11, -12.9, -14.9, -16.9, -18.9, 82.2,
  75.5, 69, 63.3, 58.4, 53.5, 48.8, 44, 39.7, 35.7, 32.1, 29.1, 26.1, 23.5,
  20.9, 18, 15.7, 13, 10.2, 7.5, 5, 2.6, 0, -2.4, -4.6, -6.9, -9, -11, -13, -15,
  -17,
];

/***********************************************************************
!  F(50,50) FIELD STRENGTH DATA FOR THE HIGH VHF PROPAGATION CURVE  ( TV CHANNELS 7 THROUGH 13 ) -- (13 points * 25 rows = 325) 
!*********************************************************************/
// was [25][13]

var F55HV = [
  94.6, 82.8, 75.7, 70.7, 66.8, 55, 42.5, 34, 26.3, 20.7, 16.3, 12.9, 9.9, 7,
  4.3, 1.5, -1, -3.5, -5.7, -8, -10.4, -12.8, -15, -17.2, -19.1, 100.7, 88.9,
  81.8, 76.9, 73, 61, 48.6, 40, 32, 24.1, 18.5, 14.4, 11.2, 8.3, 5.5, 2.9, 0.5,
  -2, -4.3, -6.9, -9.2, -11.5, -13.8, -16, -18.2, 101.6, 92.3, 86.6, 82.2, 78.8,
  67.2, 54.7, 46.1, 38.1, 30.1, 23, 17, 13.5, 10.5, 7.5, 4.8, 2.3, -0.3, -2.7,
  -5, -7.3, -9.8, -12, -14.4, -16.8, 101.8, 93.9, 88.7, 84.8, 81.6, 70.8, 58.1,
  49.8, 41.7, 33.8, 26.2, 20, 15.2, 12, 9, 6.2, 3.7, 1, -1.2, -3.7, -6, -8.4,
  -10.7, -13, -15.5, 101.9, 94.6, 89.8, 86.2, 83.2, 73.2, 60.7, 52.1, 44, 36.1,
  28.8, 22.1, 17, 13.7, 10.4, 7.5, 4.8, 2.2, -0.1, -2.5, -4.9, -7.3, -9.7, -12,
  -14.4, 102, 95, 90.5, 87, 84.5, 75, 62.5, 54.2, 46, 38, 30.6, 24, 18.9, 15,
  11.5, 8.6, 5.8, 3.2, 0.9, -1.5, -4, -6.3, -8.7, -11, -13.4, 102.3, 95.4, 91.3,
  88, 85.7, 77, 65, 56.7, 48.8, 40.9, 33.5, 26.8, 21.2, 17, 13.1, 10, 7, 4.4, 2,
  -0.5, -3, -5.3, -7.6, -10, -12.3, 102.3, 95.7, 91.8, 88.7, 86.3, 78.1, 67.6,
  59, 51, 43.5, 36.3, 29.6, 23.9, 19, 14.9, 11.2, 8.2, 5.5, 3, 0.6, -2, -4.3,
  -6.6, -9, -11.3, 102.3, 95.9, 92, 89.1, 87, 79.1, 69.5, 61, 53.3, 46, 39, 32,
  26, 21, 16.2, 12.7, 9.5, 6.5, 4, 1.5, -1, -3.5, -5.8, -8.2, -10.5, 102.4, 96,
  92.1, 89.5, 87.3, 80, 71, 62.8, 55, 47.9, 41, 34, 28, 22.6, 17.5, 13.6, 10.5,
  7.4, 4.9, 2.2, -0.2, -2.6, -5, -7.3, -9.8, 102.4, 96.2, 92.6, 90, 88, 81.1,
  73.9, 66.3, 58.7, 52, 45, 38.2, 32, 26.3, 21.1, 17, 14, 10.7, 8, 5.6, 3, 0.6,
  -1.8, -4.2, -6.6, 102.4, 96.2, 92.6, 90, 88, 81.8, 74.8, 67.4, 60.3, 53.8, 47,
  40.6, 34.4, 28.8, 23.8, 19.8, 16.6, 13.1, 10.4, 8.2, 5.5, 3.1, 0.9, -1.8, -4,
  102.5, 96.5, 92.7, 90.1, 88, 82, 75, 68, 61.1, 54.6, 48.1, 42, 36.1, 30.6,
  25.5, 21.8, 18.5, 15.1, 12.3, 10.1, 7.5, 5.1, 2.9, 0.3, -1.9,
];

/***********************************************************************
!   F(50,10) FIELD STRENGTH DATA FOR THE HIGH VHF PROPAGATION CURVE  ( TV CHANNELS 7 THROUGH 13 ) -- (13 points * 31 curves = 403)                     
!***********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]

var F51HV = [
  55.4, 44.4, 39.2, 34, 29.9, 26.6, 23.5, 20.3, 17.4, 14.3, 11.3, 8.6, 5.8, 2.9,
  0.3, -2.1, -4.4, -6.7, -8.9, -10.8, -12.9, -14.8, -16.9, -18.8, -20.7, -22.7,
  -24.6, -26.4, -28.2, -30.1, -32, 61.6, 50, 43.5, 38, 32.5, 28.2, 25, 22, 19,
  16, 13, 10, 7.2, 4.7, 1.9, -0.7, -3.2, -5.4, -7.8, -9.8, -11.8, -13.8, -15.8,
  -17.7, -19.7, -21.4, -23.3, -25.2, -27.1, -29, -30.9, 67.7, 55.8, 48.6, 42.7,
  35.9, 31, 27, 24, 21, 18.1, 15.1, 12.2, 9.4, 6.8, 3.8, 1.2, -1.4, -3.8, -6.1,
  -8.2, -10.3, -12.3, -14.3, -16.3, -18.3, -20.1, -22, -24, -25.9, -27.7, -29.5,
  71, 59.1, 52, 45.6, 38.8, 33.4, 28.9, 25.5, 22.4, 19.6, 16.7, 13.7, 10.8, 8.1,
  5.2, 2.7, 0, -2.3, -4.8, -7, -9, -11.1, -13.1, -15.1, -17, -19, -20.9, -22.9,
  -24.8, -26.5, -28.2, 73.5, 61.7, 54.6, 48, 41, 35.4, 30.7, 27, 23.8, 20.8, 18,
  15, 12, 9.5, 6.5, 3.9, 1.2, -1.2, -3.8, -6, -8.2, -10.2, -12.2, -14.2, -16.2,
  -18, -20, -21.9, -23.9, -25.5, -27.1, 75.3, 63.7, 56.5, 50, 43, 37.4, 32.3,
  28.3, 25, 22, 19.1, 16.3, 13.3, 10.6, 7.8, 5, 2.4, 0, -2.6, -5, -7.1, -9.3,
  -11.2, -13.3, -15.3, -17.2, -19.1, -21, -23, -24.9, -26.7, 77.1, 66.5, 59,
  52.5, 45.8, 40, 35, 30.4, 26.9, 23.5, 20.5, 17.6, 14.7, 12, 9, 6.4, 3.7, 1,
  -1.4, -4, -6, -8.2, -10.2, -12.3, -14.3, -16.2, -18.2, -20, -22, -23.9, -25.8,
  78.6, 68.9, 61.5, 54.9, 48.2, 43, 37.4, 32.9, 28.8, 25, 22, 18.8, 15.9, 13,
  10.3, 7.5, 4.9, 2.1, -0.3, -3, -5.1, -7.4, -9.4, -11.4, -13.5, -15.4, -17.4,
  -19.2, -21.1, -23, -24.9, 79.6, 70.8, 63.6, 56.9, 50.8, 45.4, 40, 35, 30.4,
  26.4, 23, 19.9, 17, 14.1, 11.5, 8.8, 6, 3.3, 0.8, -2, -4.2, -6.5, -8.6, -10.6,
  -12.8, -14.8, -16.8, -18.5, -20.3, -22.1, -23.9, 80.4, 72, 65.2, 58.8, 53,
  47.6, 42, 36.8, 32, 27.7, 24, 20.7, 18, 15.2, 12.5, 9.8, 7, 4.3, 1.7, -1,
  -3.3, -5.6, -7.8, -9.8, -12, -14, -16, -18, -19.6, -21.5, -23.4, 82, 75, 68.6,
  62.5, 57, 52, 46.8, 41.5, 35.8, 31, 27.6, 24, 21.4, 18.8, 16, 13.1, 10.6, 7.9,
  5, 2.5, 0, -2.4, -4.7, -6.9, -9, -11.1, -13.1, -15.1, -17, -19, -21, 82.4,
  75.9, 69.8, 64, 58.9, 53.8, 48.9, 43.7, 38.2, 33.6, 30, 26.8, 24, 21.2, 18.7,
  15.9, 13.2, 10.6, 8, 5.2, 2.8, 0.2, -2, -4.3, -6.5, -9, -11, -13, -15, -16.8,
  -18.6, 82.5, 76.2, 70.2, 64.9, 59.8, 54.8, 50, 45, 40.1, 35.5, 32, 28.9, 26,
  23.4, 20.7, 18, 15.4, 12.8, 10, 7.3, 4.9, 2.2, -0.1, -2.4, -4.7, -7, -9, -11,
  -13, -15, -17,
];

/***********************************************************************
!   F(50,50) FIELD STRENGTH DATA FOR THE UHF PROPAGATION CURVE ( TV CHANNELS 14 THROUGH 83 ) -- (13 points * 25 curves = 325)                          
!***********************************************************************/
// was [25][13]

var F55U = [
  92, 80, 72.9, 67.9, 63.8, 51.9, 39, 27.5, 17.8, 13, 10.1, 7, 4.2, 1.6, -1,
  -3.2, -5, -7.2, -9.1, -11, -13.1, -15.1, -17.2, -19.3, -21.4, 97.9, 86, 79,
  74, 70, 58, 45.2, 33.5, 22.7, 16, 11.7, 8.5, 5.5, 2.8, 0.2, -2, -4.2, -6.3,
  -8.4, -10.3, -12.3, -14.2, -16.2, -18.3, -20.1, 100.7, 91, 84.7, 80, 76, 64,
  51.2, 39.6, 28.2, 19.6, 14.4, 10.8, 7.7, 4.7, 1.9, -0.4, -2.7, -4.9, -7, -8.9,
  -10.9, -12.8, -14.8, -16.8, -18.7, 101.5, 93, 87.4, 83.3, 79.5, 67.6, 54.6,
  43, 31.5, 22.3, 16.8, 12.5, 9.3, 6, 3.2, 0.7, -1.5, -3.8, -5.9, -7.9, -9.9,
  -11.7, -13.8, -15.8, -17.7, 101.9, 94.1, 89, 85.1, 81.5, 70, 57.2, 45.7, 34.5,
  25.1, 19.1, 14.2, 10.8, 7.5, 4.6, 1.9, -0.4, -2.9, -5, -7, -9, -10.8, -12.8,
  -14.8, -16.8, 102, 94.8, 90, 86.3, 82.9, 72, 59.1, 48, 37.3, 28.3, 21.7, 16.3,
  12.4, 8.9, 5.7, 3, 0.5, -2, -4.2, -6.1, -8, -10, -11.9, -13.9, -15.9, 102.1,
  95.2, 90.8, 87.3, 84.1, 73.8, 61, 50.5, 40.3, 31.8, 24.7, 19, 14.5, 10.6, 7.1,
  4.3, 1.7, -0.9, -3.2, -5.2, -7.1, -9, -11, -13, -15, 102.2, 95.6, 91.3, 88,
  85, 75.3, 62.6, 52.3, 42.7, 34.1, 27, 21.3, 16.3, 12, 8.5, 5.6, 2.8, 0, -2.3,
  -4.3, -6.2, -8.2, -10.2, -12.2, -14.1, 102.3, 95.9, 91.8, 88.6, 85.8, 76.5,
  64, 53.9, 44.3, 36, 29.3, 23.4, 18, 13.6, 9.7, 6.7, 3.8, 1, -1.6, -3.6, -5.5,
  -7.5, -9.5, -11.4, -13.2, 102.4, 96, 92, 88.9, 86.2, 77.2, 65, 55, 45.7, 37.6,
  31, 25, 19.8, 15, 10.8, 7.7, 4.8, 1.9, -0.9, -3, -4.8, -6.8, -8.9, -10.8,
  -12.5, 102.5, 96.3, 92.5, 89.6, 87.3, 79.6, 68.2, 58.4, 49.4, 41.7, 35.4,
  29.8, 24.5, 19.8, 15, 11.5, 8.2, 5, 2, -0.2, -2.2, -4.3, -6.3, -8.3, -10,
  102.5, 96.5, 92.8, 90, 87.9, 80.5, 70, 60.8, 52.1, 44.8, 38.6, 33, 28, 23.4,
  18.8, 14.8, 11.1, 7.8, 4.6, 1.9, -0.1, -2.2, -4.2, -6.1, -8, 102.5, 96.5, 93,
  90.3, 88.1, 81, 71.1, 62.5, 54, 46.7, 41, 35.7, 30.8, 26, 21.8, 17.5, 13.7,
  10, 6.7, 3.7, 1.7, -0.4, -2.3, -4.4, -6.3,
];

/***********************************************************************
!   F(50,10) FIELD STRENGTH DATA FOR THE UHF PROPAGATION CURVE ( TV CHANNELS 14 THROUGH 83 )  - (13 points * 31 curves = 403)                          
!***********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]

var F51U = [
  52.2, 41.6, 35, 30.3, 27, 23.8, 20.8, 17.8, 14.8, 12, 9.2, 6.6, 4, 1.2, -1.3,
  -3.8, -6, -8.4, -10.3, -12.5, -14.5, -16.5, -18.5, -20.5, -22.4, -24.2, -26,
  -27.8, -29.5, -31, -32.5, 58.3, 46.7, 38, 32.1, 28.3, 25.2, 22.2, 19.3, 16.5,
  13.4, 10.7, 8, 5.1, 2.5, -0.2, -2.4, -4.9, -7.2, -9.3, -11.3, -13.5, -15.5,
  -17.4, -19.3, -21.3, -23.2, -25, -27, -28.5, -30.1, -31.6, 64.7, 52.4, 43,
  35.3, 30.8, 27.6, 24.5, 21.3, 18.5, 15.6, 12.7, 9.9, 7.1, 4.4, 1.8, -0.8,
  -3.1, -5.5, -7.7, -9.8, -12, -14, -15.9, -17.8, -19.8, -21.6, -23.4, -25.5,
  -27.1, -28.9, -30.7, 68, 56, 46.3, 37.6, 32.6, 29.1, 26, 23, 20, 17.1, 14,
  11.2, 8.8, 6, 3.2, 0.8, -1.7, -4.1, -6.2, -8.4, -10.4, -12.7, -14.6, -16.5,
  -18.6, -20.4, -22.2, -24.2, -26, -27.9, -29.8, 70.5, 58.5, 48.8, 40, 34.7,
  30.4, 27.2, 24.2, 21.2, 18.3, 15.2, 12.6, 10, 7.3, 4.6, 1.9, -0.5, -3, -5.2,
  -7.4, -9.6, -11.7, -13.8, -15.6, -17.7, -19.6, -21.3, -23.3, -25, -27, -29,
  72.3, 60.3, 50.8, 42.4, 36.7, 32, 28.4, 25.4, 22.4, 19.7, 16.5, 13.8, 11, 8.3,
  5.7, 3, 0.6, -2, -4.3, -6.6, -8.8, -10.8, -13, -14.9, -17, -18.9, -20.8,
  -22.7, -24.4, -26.3, -28.2, 74.1, 62.3, 52.9, 45.1, 39, 34.5, 30.4, 27, 23.9,
  21, 18, 15.3, 12.5, 9.7, 7, 4.4, 1.8, -0.7, -3.2, -5.4, -7.7, -9.8, -12, -14,
  -16, -17.9, -19.9, -21.8, -23.7, -25.6, -27.5, 75.4, 63.9, 54.9, 47.1, 40.8,
  36.4, 32.2, 28.8, 25.2, 22.1, 19.3, 16.4, 13.8, 10.9, 8.1, 5.6, 2.9, 0.3,
  -2.2, -4.5, -6.7, -8.9, -11, -13, -15, -17, -19.1, -21, -22.8, -24.8, -26.8,
  76.4, 65.2, 56.3, 48.7, 42.4, 37.9, 33.9, 30.2, 26.6, 23.4, 20.3, 17.3, 14.8,
  11.9, 9.1, 6.7, 3.9, 1.3, -1.2, -3.6, -5.8, -7.9, -10, -12.2, -14.2, -16.2,
  -18.2, -20.2, -22, -24, -26, 77.4, 66.2, 57.6, 50, 43.7, 39, 35.1, 31.7, 27.8,
  24.6, 21.3, 18.3, 15.7, 12.8, 10, 7.6, 4.8, 2.1, -0.4, -2.8, -5, -7.1, -9.2,
  -11.3, -13.4, -15.4, -17.5, -19.4, -21.3, -23.2, -25.1, 79.5, 69.3, 60.9,
  53.6, 47.7, 43.1, 39.2, 35.8, 32, 28.3, 24.9, 21.7, 18.8, 15.9, 13.1, 10.6,
  7.9, 5.1, 2.2, 0, -2.2, -4.3, -6.6, -8.9, -11, -13, -15, -17, -19, -21, -22.9,
  80.7, 71.2, 63, 56.1, 50.2, 46, 42.1, 38.7, 35, 31.3, 27.8, 24.3, 21.2, 18.2,
  15.5, 12.8, 10, 7.3, 4.7, 2.1, 0, -2.2, -4.6, -6.8, -8.8, -10.8, -12.9, -14.9,
  -16.9, -18.9, -20.9, 81.3, 72.6, 64.5, 58, 52.4, 48, 44.3, 40.7, 37.3, 33.8,
  30.3, 27, 23.7, 20.5, 17.4, 14.7, 12, 9.2, 6.5, 4, 1.8, -0.4, -2.8, -5, -7,
  -9, -11, -13, -15, -16.8, -18.6,
];

/*  TVFMFS:  DATA TABLE INITIALIZATION OK, CONTINUE WITH PROGRAM   */

// ========The following data is needed for fzq to calculate F(50,90) or other curves ================//

var VGRID = [
  0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.15, 0.2, 0.3,
  0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.2, 1.4, 1.6, 1.8, 2, 3, 4, 5, 6, 7, 8, 9,
  10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 24, 26, 28, 30, 32, 34, 36,
  38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
  76, 78, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
  97, 98, 98.2, 98.4, 98.6, 98.8, 99, 99.1, 99.2, 99.3, 99.4, 99.5, 99.6, 99.7,
  99.8, 99.85, 99.9, 99.91, 99.92, 99.93, 99.94, 99.95, 99.96, 99.97, 99.98,
  99.99,
];

var ZGRI = [
  -3.71902, -3.54008, -3.43161, -3.35279, -3.29053, -3.23888, -3.19465,
  -3.15591, -3.12139, -3.09023, -2.96774, -2.87816, -2.74778, -2.65207,
  -2.57583, -2.51214, -2.45726, -2.40892, -2.36562, -2.32635, -2.25713,
  -2.19729, -2.14441, -2.09693, -2.05375, -1.88079, -1.75069, -1.64485,
  -1.55477, -1.47579, -1.40507, -1.34076, -1.28155, -1.22653, -1.17499,
  -1.12639, -1.08032, -1.03643, -0.99446, -0.95416, -0.91537, -0.8779, -0.84162,
  -0.77219, -0.7063, -0.64335, -0.58284, -0.5244, -0.4677, -0.41246, -0.35846,
  -0.30548, -0.25335, -0.20189, -0.15097, -0.10043, -0.05015,
];

/*
//------- ITPLBV --------------------------------------------------------------------------------------------------
// Interpolation subroutine, this is a bi-variate surface fitting procedure, refer to the original FCC CURVES program
// and to the paper referenced in comments above for details.  Sorry about the shortage of comments, but there were
// none in the original source.

// This has been modified from the original, taking into account the context in which it is being used.  It was a full
// general-purpose routine, however many of the conditions that had exception-handling could never have occurred given
// the limited range of possible values in context.  Much of that unnecessary code has been eliminated.

// Arguments:

//    lx  Number of columns in table.
//    ly  Number of rows in table.
//    x   Column enumeration values.
//    y   Row enumeration values.
//    z   Data table.
//    n   Number of points to lookup.
//    u   Column values for lookup points.
//    v   Row values for lookup points.
//    w   Return result of lookups.
*/

function itplbv(lx, ly, x, y, z, n, u, v, w) {
  // declarations and initializations

  var lxm1, lxp1, lym1, lyp1, ixpv, iypv, k, ix, iy, imn, imx, jx, jy, jx1, jy1;
  lxm1 =
    lxp1 =
    lym1 =
    lyp1 =
    ixpv =
    iypv =
    k =
    ix =
    iy =
    imn =
    imx =
    jx =
    jy =
    jx1 =
    jy1 =
      0;

  var za_row0 = [0, 0];
  var za_row1 = [0, 0];
  var za_row2 = [0, 0];
  var za_row3 = [0, 0];
  var za_row4 = [0, 0];
  var za = [za_row0, za_row1, za_row2, za_row3, za_row4]; // za[5,2]

  var zb_row0 = [0, 0, 0, 0, 0];
  var zb_row1 = [0, 0, 0, 0, 0];
  var zb = [zb_row0, zb_row1]; // zb[2,5]

  var zab_row0 = [0, 0, 0];
  var zab_row1 = [0, 0, 0];
  var zab_row2 = [0, 0, 0];
  var zab = [zab_row0, zab_row1, zab_row2]; // zab[3,3]

  var zx_row0 = [0, 0, 0, 0];
  var zx_row1 = [0, 0, 0, 0];
  var zx_row2 = [0, 0, 0, 0];
  var zx_row3 = [0, 0, 0, 0];
  var zx = [zx_row0, zx_row1, zx_row2, zx_row3]; // zx[4,4]

  var zy_row0 = [0, 0, 0, 0];
  var zy_row1 = [0, 0, 0, 0];
  var zy_row2 = [0, 0, 0, 0];
  var zy_row3 = [0, 0, 0, 0];
  var zy = [zy_row0, zy_row1, zy_row2, zy_row3]; // zy[4,4]

  var zxy_row0 = [0, 0, 0, 0];
  var zxy_row1 = [0, 0, 0, 0];
  var zxy_row2 = [0, 0, 0, 0];
  var zxy_row3 = [0, 0, 0, 0];
  var zxy = [zxy_row0, zxy_row1, zxy_row2, zxy_row3]; // zy[4,4]

  var x3,
    x4,
    a3,
    y3,
    y4,
    b3,
    z33,
    z43,
    z34,
    z44,
    x2,
    a2,
    z23,
    z24,
    x5,
    a4,
    z53,
    z54;
  x3 =
    x4 =
    a3 =
    y3 =
    y4 =
    b3 =
    z33 =
    z43 =
    z34 =
    z44 =
    x2 =
    a2 =
    z23 =
    z24 =
    x5 =
    a4 =
    z53 =
    z54 =
      0.0;

  var a1,
    a5,
    y2,
    b2,
    z32,
    z42,
    y5,
    b4,
    z35,
    z45,
    b1,
    b5,
    w2,
    w3,
    sw,
    wx2,
    wx3,
    wy2,
    wy3,
    w1,
    w4,
    w5;
  a1 =
    a5 =
    y2 =
    b2 =
    z32 =
    z42 =
    y5 =
    b4 =
    z35 =
    z45 =
    b1 =
    b5 =
    w2 =
    w3 =
    sw =
    wx2 =
    wx3 =
    wy2 =
    wy3 =
    w1 =
    w4 =
    w5 =
      0.0;

  var zx3b3,
    zx4b3,
    zy3a3,
    zy4a3,
    a,
    b,
    c,
    d,
    e,
    a3sq,
    b3sq,
    p02,
    p03,
    p12,
    p13,
    p20,
    p21,
    p22;
  zx3b3 =
    zx4b3 =
    zy3a3 =
    zy4a3 =
    a =
    b =
    c =
    d =
    e =
    a3sq =
    b3sq =
    p02 =
    p03 =
    p12 =
    p13 =
    p20 =
    p21 =
    p22 =
      0.0;

  var p23, p30, p31, p32, p33, dy, q0, q1, q2, q3, dx;
  p23 = p30 = p31 = p32 = p33 = dy = q0 = q1 = q2 = q3 = dx = 0.0;

  // Calculations begin

  lx = Math.floor(lx);
  ly = Math.floor(ly);

  lxm1 = Math.floor(lx - 1);
  lxp1 = Math.floor(lx + 1);
  lym1 = Math.floor(ly - 1);
  lyp1 = Math.floor(ly + 1);
  ixpv = -1;
  iypv = -1;
  for (k = 0; k < n; k++) {
    if (u[k] >= x[lxm1]) {
      ix = lx;
    } else {
      if (u[k] < x[0]) {
        ix = 0;
      } else {
        imn = 1;
        imx = lxm1;
        do {
          ix = Math.floor((imn + imx) / 2);
          if (u[k] >= x[ix]) {
            imn = ix + 1;
          } else {
            imx = ix;
          }
        } while (imx > imn);
        ix = imx;
      }
    }
    ix = Math.floor(ix);

    if (v[k] >= y[lym1]) {
      iy = ly;
    } else {
      if (v[k] < y[0]) {
        iy = 0;
      } else {
        imn = 1;
        imx = lym1;
        do {
          iy = Math.floor((imn + imx) / 2);
          if (v[k] >= y[iy]) {
            imn = iy + 1;
          } else {
            imx = iy;
          }
        } while (imx > imn);
        iy = imx;
      }
    }
    iy = Math.floor(iy);

    if (ix != ixpv || iy != iypv) {
      ixpv = ix;
      iypv = iy;
      if (ix == 0) {
        jx = 1;
      } else {
        if (ix == lx) {
          jx = lxm1;
        } else {
          jx = ix;
        }
      }
      if (iy == 0) {
        jy = 1;
      } else {
        if (iy == ly) {
          jy = lym1;
        } else {
          jy = iy;
        }
      }
      jx = Math.floor(jx);
      jy = Math.floor(jy);

      x3 = x[jx - 1];
      x4 = x[jx];
      a3 = 1 / (x4 - x3);
      y3 = y[jy - 1];
      y4 = y[jy];
      b3 = 1 / (y4 - y3);
      z33 = z[jx - 1 + (jy - 1) * lx];
      z43 = z[jx + (jy - 1) * lx];
      z34 = z[jx - 1 + jy * lx];
      z44 = z[jx + jy * lx];
      za[2][0] = (z43 - z33) * a3;
      za[2][1] = (z44 - z34) * a3;
      zb[0][2] = (z34 - z33) * b3;
      zb[1][2] = (z44 - z43) * b3;
      zab[1][1] = (zb[1][2] - zb[0][2]) * a3;
      if (jx > 1) {
        x2 = x[jx - 2];
        a2 = 1 / (x3 - x2);
        z23 = z[jx - 2 + (jy - 1) * lx];
        z24 = z[jx - 2 + jy * lx];
        za[1][0] = (z33 - z23) * a2;
        za[1][1] = (z34 - z24) * a2;
        if (jx == lxm1) {
          za[3][0] = 2 * za[2][0] - za[1][0];
          za[3][1] = 2 * za[2][1] - za[1][1];
        }
      }

      if (jx < lxm1) {
        x5 = x[jx + 1];
        a4 = 1 / (x5 - x4);
        z53 = z[jx + 1 + (jy - 1) * lx];
        z54 = z[jx + 1 + jy * lx];
        za[3][0] = (z53 - z43) * a4;
        za[3][1] = (z54 - z44) * a4;
        if (jx == 1) {
          za[1][0] = 2 * za[2][0] - za[3][0];
          za[1][1] = 2 * za[2][1] - za[3][1];
        }
      }

      zab[0][1] = (za[1][1] - za[1][0]) * b3;
      zab[2][1] = (za[3][1] - za[3][0]) * b3;
      if (jx > 2) {
        a1 = 1 / (x2 - x[jx - 3]);
        za[0][0] = (z23 - z[jx - 3 + (jy - 1) * lx]) * a1;
        za[0][1] = (z24 - z[jx - 3 + jy * lx]) * a1;
      } else {
        za[0][0] = 2 * za[1][0] - za[2][0];
        za[0][1] = 2 * za[1][1] - za[2][1];
      }
      if (jx < lx - 2) {
        a5 = 1 / (x[jx + 2] - x5);
        za[4][0] = (z[jx + 2 + (jy - 1) * lx] - z53) * a5;
        za[4][1] = (z[jx + 2 + jy * lx] - z54) * a5;
      } else {
        za[4][0] = 2 * za[3][0] - za[2][0];
        za[4][1] = 2 * za[3][1] - za[2][1];
      }
      if (jy > 1) {
        y2 = y[jy - 2];
        b2 = 1 / (y3 - y2);
        z32 = z[jx - 1 + (jy - 2) * lx];
        z42 = z[jx + (jy - 2) * lx];
        zb[0][1] = (z33 - z32) * b2;
        zb[1][1] = (z43 - z42) * b2;
        if (jy == lym1) {
          zb[0][3] = 2 * zb[0][2] - zb[0][1];
          zb[1][3] = 2 * zb[1][2] - zb[1][1];
        }
      }
      if (jy < lym1) {
        y5 = y[jy + 1];
        b4 = 1 / (y5 - y4);
        z35 = z[jx - 1 + (jy + 1) * lx];
        z45 = z[jx + (jy + 1) * lx];
        zb[0][3] = (z35 - z34) * b4;
        zb[1][3] = (z45 - z44) * b4;
        if (jy == 1) {
          zb[0][1] = 2 * zb[0][2] - zb[0][3];
          zb[1][1] = 2 * zb[1][2] - zb[1][3];
        }
      }
      zab[1][0] = (zb[1][1] - zb[0][1]) * a3;
      zab[1][2] = (zb[1][3] - zb[0][3]) * a3;
      if (jy > 2) {
        b1 = 1 / (y2 - y[jy - 3]);
        zb[0][0] = (z32 - z[jx - 1 + (jy - 3) * lx]) * b1;
        zb[1][0] = (z42 - z[jx + (jy - 3) * lx]) * b1;
      } else {
        zb[0][0] = 2 * zb[0][1] - zb[0][2];
        zb[1][0] = 2 * zb[1][1] - zb[1][2];
      }
      if (jy < ly - 2) {
        b5 = 1 / (y[jy + 2] - y5);
        zb[0][4] = (z[jx - 1 + (jy + 2) * lx] - z35) * b5;
        zb[1][4] = (z[jx + (jy + 2) * lx] - z45) * b5;
      } else {
        zb[0][4] = 2 * zb[0][3] - zb[0][2];
        zb[1][4] = 2 * zb[1][3] - zb[1][2];
      }
      if (jx < lxm1) {
        if (jy > 1) {
          zab[2][0] = ((z53 - z[jx + 1 + (jy - 2) * lx]) * b2 - zb[1][1]) * a4;
          if (jy < lym1) {
            zab[2][2] =
              ((z[jx + 1 + (jy + 1) * lx] - z54) * b4 - zb[1][3]) * a4;
          } else {
            zab[2][2] = 2 * zab[2][1] - zab[2][0];
          }
        } else {
          zab[2][2] = ((z[jx + 1 + (jy + 1) * lx] - z54) * b4 - zb[1][3]) * a4;
          zab[2][0] = 2 * zab[2][1] - zab[2][2];
        }
        if (jx == 1) {
          zab[0][0] = 2 * zab[1][0] - zab[2][0];
          zab[0][2] = 2 * zab[1][2] - zab[2][2];
        }
      }
      if (jx > 1) {
        if (jy > 1) {
          zab[0][0] = (zb[0][1] - (z23 - z[jx - 2 + (jy - 2) * lx]) * b2) * a2;
          if (jy < lym1) {
            zab[0][2] =
              (zb[0][3] - (z[jx - 2 + (jy + 1) * lx] - z24) * b4) * a2;
          } else {
            zab[0][2] = 2 * zab[0][1] - zab[0][0];
          }
        } else {
          zab[0][2] = (zb[0][3] - (z[jx - 2 + (jy + 1) * lx] - z24) * b4) * a2;
          zab[0][0] = 2 * zab[0][1] - zab[0][2];
        }
        if (jx == lxm1) {
          zab[2][0] = 2 * zab[1][0] - zab[0][0];
          zab[2][2] = 2 * zab[1][2] - zab[0][2];
        }
      }
      for (jy = 1; jy < 3; jy++) {
        for (jx = 1; jx < 3; jx++) {
          w2 = Math.abs(za[jx + 2][jy - 1] - za[jx + 1][jy - 1]);
          w3 = Math.abs(za[jx][jy - 1] - za[jx - 1][jy - 1]);
          sw = w2 + w3;
          if (sw >= 1e-7) {
            wx2 = w2 / sw;
            wx3 = w3 / sw;
          } else {
            wx2 = 0.5;
            wx3 = 0.5;
          }
          zx[jx][jy] = wx2 * za[jx][jy - 1] + wx3 * za[jx + 1][jy - 1];
          w2 = Math.abs(zb[jx - 1][jy + 2] - zb[jx - 1][jy + 1]);
          w3 = Math.abs(zb[jx - 1][jy] - zb[jx - 1][jy - 1]);
          sw = w2 + w3;
          if (sw >= 1e-7) {
            wy2 = w2 / sw;
            wy3 = w3 / sw;
          } else {
            wy2 = 0.5;
            wy3 = 0.5;
          }
          zy[jx][jy] = wy2 * zb[jx - 1][jy] + wy3 * zb[jx - 1][jy + 1];
          zxy[jx][jy] =
            wy2 * (wx2 * zab[jx - 1][jy - 1] + wx3 * zab[jx][jy - 1]) +
            wy3 * (wx2 * zab[jx - 1][jy] + wx3 * zab[jx][jy]);
        }
      }
      if (ix == 0) {
        w2 = a4 * (3 * a3 + a4);
        w1 = 2 * a3 * (a3 - a4) + w2;
        for (jy = 1; jy < 3; jy++) {
          zx[0][jy] = (w1 * za[0][jy - 1] + w2 * za[1][jy - 1]) / (w1 + w2);
          zy[0][jy] = 2 * zy[1][jy] - zy[2][jy];
          zxy[0][jy] = 2 * zxy[1][jy] - zxy[2][jy];
          for (jx1 = 1; jx1 < 3; jx1++) {
            jx = 3 - jx1;
            zx[jx][jy] = zx[jx - 1][jy];
            zy[jx][jy] = zy[jx - 1][jy];
            zxy[jx][jy] = zxy[jx - 1][jy];
          }
        }
        x3 -= 1 / a4;
        z33 -= za[1][0] / a4;
        for (jy = 0; jy < 5; jy++) {
          zb[1][jy] = zb[0][jy];
        }
        for (jy = 1; jy < 4; jy++) {
          zb[0][jy] -= zab[0][jy - 1] / a4;
        }
        a3 = a4;
        za[2][0] = za[1][0];
        for (jy = 0; jy < 3; jy++) {
          zab[1][jy] = zab[0][jy];
        }
      }
      if (ix == lx) {
        w4 = a2 * (3 * a3 + a2);
        w5 = 2 * a3 * (a3 - a2) + w4;
        for (jy = 1; jy < 3; jy++) {
          zx[3][jy] = (w4 * za[3][jy - 1] + w5 * za[4][jy - 1]) / (w4 + w5);
          zy[3][jy] = 2 * zy[2][jy] - zy[1][jy];
          zxy[3][jy] = 2 * zxy[2][jy] - zxy[1][jy];
          for (jx = 1; jx < 3; jx++) {
            zx[jx][jy] = zx[jx + 1][jy];
            zy[jx][jy] = zy[jx + 1][jy];
            zxy[jx][jy] = zxy[jx + 1][jy];
          }
        }
        x3 = x4;
        z33 = z43;
        for (jy = 0; jy < 5; jy++) {
          zb[0][jy] = zb[1][jy];
        }
        a3 = a2;
        za[2][0] = za[3][0];
        for (jy = 0; jy < 3; jy++) {
          zab[1][jy] = zab[2][jy];
        }
      }
      if (iy == 0) {
        w2 = b4 * (3 * b3 + b4);
        w1 = 2 * b3 * (b3 - b4) + w2;
        for (jx = 1; jx < 3; jx++) {
          if ((ix > 0 || jx == 2) && (ix < lx || jx == 1)) {
            zy[jx][0] = (w1 * zb[jx - 1][0] + w2 * zb[jx - 1][1]) / (w1 + w2);
            zx[jx][0] = 2 * zx[jx][1] - zx[jx][2];
            zxy[jx][0] = 2 * zxy[jx][1] - zxy[jx][2];
          }
          for (jy1 = 1; jy1 < 3; jy1++) {
            jy = 3 - jy1;
            zy[jx][jy] = zy[jx][jy - 1];
            zx[jx][jy] = zx[jx][jy - 1];
            zxy[jx][jy] = zxy[jx][jy - 1];
          }
        }
        y3 -= 1 / b4;
        z33 -= zb[0][1] / b4;
        za[2][0] -= zab[1][0] / b4;
        zb[0][2] = zb[0][1];
        zab[1][1] = zab[1][0];
        b3 = b4;
        if (ix == 0 || ix == lx) {
          if (ix == 0) {
            jx = 1;
            jx1 = 2;
          } else {
            jx = 2;
            jx1 = 1;
          }
          jx1 = Math.floor(jx1);
          zx[jx][1] = zx[jx1][1] + zx[jx][2] - zx[jx1][2];
          zy[jx][1] = zy[jx1][1] + zy[jx][2] - zy[jx1][2];
          zxy[jx][1] = zxy[jx1][1] + zxy[jx][2] - zxy[jx1][2];
        }
      }
      if (iy == ly) {
        w4 = b2 * (3 * b3 + b2);
        w5 = 2 * b3 * (b3 - b2) + w4;
        for (jx = 1; jx < 3; jx++) {
          if ((ix > 0 || jx == 2) && (ix < lx || jx == 1)) {
            zy[jx][3] = (w4 * zb[jx - 1][3] + w5 * zb[jx - 1][4]) / (w4 + w5);
            zx[jx][3] = 2 * zx[jx][2] - zx[jx][1];
            zxy[jx][3] = 2 * zxy[jx][2] - zxy[jx][1];
          }
          for (jy = 1; jy < 3; jy++) {
            zy[jx][jy] = zy[jx][jy + 1];
            zx[jx][jy] = zx[jx][jy + 1];
            zxy[jx][jy] = zxy[jx][jy + 1];
          }
        }
        y3 = y4;
        z33 += zb[0][2] / b3;
        za[2][0] += zab[1][1] / b3;
        zb[0][2] = zb[0][3];
        zab[1][1] = zab[1][2];
        b3 = b2;
        if (ix == 0 || ix == lx) {
          if (ix == 0) {
            jx = 1;
            jx1 = 2;
          } else {
            jx = 2;
            jx1 = 1;
          }
          zx[jx][2] = zx[jx1][2] + zx[jx][1] - zx[jx1][1];
          zy[jx][2] = zy[jx1][2] + zy[jx][1] - zy[jx1][1];
          zxy[jx][2] = zxy[jx1][2] + zxy[jx][1] - zxy[jx1][1];
        }
      }
      zx3b3 = (zx[1][2] - zx[1][1]) * b3;
      zx4b3 = (zx[2][2] - zx[2][1]) * b3;
      zy3a3 = (zy[2][1] - zy[1][1]) * a3;
      zy4a3 = (zy[2][2] - zy[1][2]) * a3;
      a = zab[1][1] - zx3b3 - zy3a3 + zxy[1][1];
      b = zx4b3 - zx3b3 - zxy[2][1] + zxy[1][1];
      c = zy4a3 - zy3a3 - zxy[1][2] + zxy[1][1];
      d = zxy[2][2] - zxy[2][1] - zxy[1][2] + zxy[1][1];
      e = a + a - b - c;
      a3sq = a3 * a3;
      b3sq = b3 * b3;
      p02 = (2 * (zb[0][2] - zy[1][1]) + zb[0][2] - zy[1][2]) * b3;
      p03 = (-2 * zb[0][2] + zy[1][2] + zy[1][1]) * b3sq;
      p12 = (2 * (zx3b3 - zxy[1][1]) + zx3b3 - zxy[1][2]) * b3;
      p13 = (-2 * zx3b3 + zxy[1][2] + zxy[1][1]) * b3sq;
      p20 = (2 * (za[2][0] - zx[1][1]) + za[2][0] - zx[2][1]) * a3;
      p21 = (2 * (zy3a3 - zxy[1][1]) + zy3a3 - zxy[2][1]) * a3;
      p22 = (3 * (a + e) + d) * a3 * b3;
      p23 = (-3 * e - b - d) * a3 * b3sq;
      p30 = (-2 * za[2][0] + zx[2][1] + zx[1][1]) * a3sq;
      p31 = (-2 * zy3a3 + zxy[2][1] + zxy[1][1]) * a3sq;
      p32 = (-3 * e - c - d) * b3 * a3sq;
      p33 = (d + e + e) * a3sq * b3sq;
    }
    dy = v[k] - y3;
    q0 = z33 + dy * (zy[1][1] + dy * (p02 + dy * p03));
    q1 = zx[1][1] + dy * (zxy[1][1] + dy * (p12 + dy * p13));
    q2 = p20 + dy * (p21 + dy * (p22 + dy * p23));
    q3 = p30 + dy * (p31 + dy * (p32 + dy * p33));
    dx = u[k] - x3;
    w[k] = q0 + dx * (q1 + dx * (q2 + dx * q3));
  }
} // end itplbv function ---------------------------------------------------------------------

function tvfmfs_metric(
  erp,
  haat,
  channel,
  field,
  distance,
  fs_or_dist,
  curve,
  flag
) {
  var id50 = 25;
  var ih50 = 13;
  var id10 = 31;
  var ih10 = 13;
  var range = 100;
  var delta = 0.5;
  var erp_db = 0.0;
  var d_first = 0.0;
  var d_last = 0.0;
  var e_volts_meter = 0.0;
  var n_points = 1001;

  var rhaat = 10000; // Set to a big impossible number

  //var erp_copy = erp;
  //var distance_copy = distance;
  //var field_copy = field;

  var i = 0;
  var j = 1;

  var d = [];
  var h = [];
  var f = [];
  var f5050 = [];
  var f5010 = [];

  //For F(50,90) curves
  var L = 50.0;
  var T = 90.0;
  var ZQ = 0.0;
  var sigma = 0.0;
  var RL = 0.0;
  var RT = 0.0;

  //var flag = [];

  for (i = 0; i < 19; i++) flag[i] = 0;

  // Input data checks

  if (
    channel < 2 ||
    channel > 300 ||
    (channel > 83 && channel < 200) ||
    channel == ""
  ) {
    flag[3] = 1;
  }
  if (erp < 0.0001) {
    flag[6] = 1;
    if (erp < 0.0001 && erp > 0.00000001) {
      erp = 0.0001;
    }
  }

  if (
    ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) &&
    erp > 400.5
  ) {
    flag[12] = 1;
  } else if (channel >= 7 && channel <= 13 && erp > 400.5) {
    flag[13] = 1;
  } else if (channel >= 14 && channel <= 69 && erp > 5500.5) {
    flag[14] = 1;
  }

  if ((curve == 0 || curve == 2) && distance > 300) {
    flag[15] = 1;
  } else if (curve == 1 && distance > 500) {
    flag[16] = 1;
  }

  if (curve < 0 || curve > 2 || curve == "") {
    flag[4] = 1;
  }
  if (fs_or_dist < 1 || fs_or_dist > 3 || fs_or_dist == "") {
    flag[5] = 1;
  }
  if (fs_or_dist == 1 && field < 0.0) {
    flag[9] = 1;
    field = Math.abs(field);
  }
  if (fs_or_dist == 2 && distance < 0.0) {
    flag[9] = 1;
    distance = Math.abs(distance);
  }

  if (fs_or_dist == 3) {
    //find FM ERP, given a HAAT and a distance
    var field_for_erp = 60; // 60 dBu used to determin equivalence
    erp = 1.0; // initial value
    if (channel < 200) flag[17] = 1; // No TV calculations here
    curve = 0; // Service contour only
    channel = 250;
  }

  erp_db = 10.0 * (Math.log(erp) / Math.log(10));
  // Math.log(x)/Math.log(10) = log10(x) which is not supported in some browsers

  if (flag[3] == 1 || flag[4] == 1 || flag[5] == 1) {
    return flag;
  } //need more info -- NO CALCULATIONS
  else if (
    flag[12] == 1 ||
    flag[13] == 1 ||
    flag[14] == 1 ||
    flag[15] == 1 ||
    flag[16] == 1 ||
    flag[17] == 1
  ) {
    return flag;
  } //need more info -- NO CALCULATIONS

  //Test input values (channel may be different, as set above)
  // alert(erp + " " + haat + " " + channel + " " + field + " " + distance + " " + fs_or_dist + " " + curve);

  /***********************************************************************
!     FOR fs_or_dist = 1, FIND THE "FIELD" AT THE DISTANCE SPECIFIED IN    *
!     "DISTANCE".  IF THE DISTANCE IS LESS THAN 1.5 KM, USE THE FREE   *
!     SPACE EQUATION.                                                  *
!**********************************************************************/

  if (fs_or_dist == 1 || fs_or_dist == 3) {
    n_points = 1;
    j = 1;
    if (distance < 1.5) {
      field = 106.92 - 20.0 * (Math.log(distance) / Math.log(10)) + erp_db;
      // Math.log(x)/Math.log(10) = log10(x) which is not supported in some browsers (Internet Explorer)

      flag[1] = 1;

      return field;
    }
    if ((curve == 0 && distance > 300.0) || (curve == 1 && distance > 500.0)) {
      flag[2] = 1;
    } else {
      h[0] = haat; // Only one point sought
      d[0] = distance;

      // Next two lines added 5/13/20

      if (haat < 30) {
        h[0] = 30;
        flag[7] = 1;
      } // All HAAT below 30 meters are set to 30
      if (haat > 1600) {
        h[0] = 1600;
        flag[8] = 1;
      } // All HAAT above 1600 are set to 1600

      RL = 0.0;

      if (
        (channel >= 2 && channel <= 6) ||
        (channel >= 200 && channel <= 300)
      ) {
        // FM & analog TV channels 2-6
        if (curve == 0 || (curve == 1 && distance < 15.0)) {
          itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f);
        } else if (curve == 1) {
          itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f);
        } else if (curve == 2) {
          if (distance >= 15) {
            itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
            itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f5010);
          } else if (distance < 15) {
            itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
            f5010[0] = f5050[0]; // use F5050 curves below 15 km
          }

          // F(50,90) means field strength at 50% of the locations, 90% of the time
          // Here we can alter the location variability parameter L.  This changes the field strength result.
          // But since in practice, we never use this, it is commented out.
          // It is retained here for reference only.

          // if( L != 50. )
          // {
          //  ZQ = fzq(L);
          //  sigma = 11.88; // > 470 MHz
          //  RL = ZQ * sigma;
          // }
        }
      } else if (channel >= 7 && channel <= 13) {
        if (curve == 0 || (curve == 1 && distance < 15.0)) {
          itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f);
        } else if (curve == 1) {
          itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f);
        } else if (curve == 2) {
          if (distance >= 15) {
            itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
            itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f5010);
          } else if (distance < 15) {
            itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
            f5010[0] = f5050[0]; // use F5050 curves below 15 km
          }

          // F(50,90) means field strength at 50% of the locations, 90% of the time
          // Here we can alter the location variability parameter L.  This changes the field strength result.
          // But since in practice, we never use this, it is commented out.
          // It is retained here for reference only.

          // if( L != 50. )
          // {
          //  ZQ = fzq(L);
          //  sigma = 11.88; // > 470 MHz
          //  RL = ZQ * sigma;
          // }
        }
      } else if (channel >= 14 && channel <= 83) {
        if (curve == 0 || (curve == 1 && distance < 15.0)) {
          //F(50,50)
          itplbv(id50, ih50, D50, H50, F55U, j, d, h, f);
        } else if (curve == 1) {
          // F(50,10)
          itplbv(id10, ih10, D10, H10, F51U, j, d, h, f);
        } else if (curve == 2) {
          // F(50,90)
          if (distance >= 15) {
            itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
            itplbv(id10, ih10, D10, H10, F51U, j, d, h, f5010);
          } else if (distance < 15) {
            itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
            f5010[0] = f5050[0]; // use F5050 curves below 15 km
          }

          // F(50,90) means field strength at 50% of the locations, 90% of the time
          // Here we can alter the location variability parameter L.  This changes the field strength result.
          // But since in practice, we never use this, it is commented out.
          // It is retained here for reference only.

          // if( L != 50. )
          // {
          //  ZQ = fzq(L);
          //  sigma = 11.88; // > 470 MHz
          //  RL = ZQ * sigma;
          // }
        }
      }
    }
    if (flag[1] == 1) {
    } // no changes to field value
    if (curve == 0 || curve == 1) {
      field = f[0] + erp_db;
    } else if (curve == 2) {
      ZQ = fzq(T);

      RT = (f5010[0] - f5050[0]) * (ZQ / 1.28155);

      field = f5050[0] + RL + RT + erp_db;
    }

    if (fs_or_dist == 3) {
      // then we find the FM ERP in kW and return that
      erp = Math.pow(10, (field_for_erp - field) / 10);

      if (erp > 100) flag[10] = 1;

      return erp;
    } else {
      return field;
    }
  } // end fs_or_dist == 1

  /***********************************************************************
!     FOR fs_or_dist = 2, THE "DISTANCE" FOR A SPECIFIED "FIELD" VALUE IS
!     FOUND BY COMPUTING A FIELD VS. DISTANCE CURVE AT
!     INCREMENTS OF 0.5 KILOMETER AND THEN FINDING THE CORRECT DISTANCE VALUE
!     BY  INTERPOLATING BETWEEN THE FIELD POINTS.                          
!***********************************************************************/
  else if (fs_or_dist == 2) {
    j = n_points;

    for (i = 0; i <= n_points; i++) {
      h[i] = haat;
      f5050[i] = f5010[i] = f[i] = d[i] = 0.0;

      // Next two lines added 5/13/20
      if (h[i] < 30) {
        h[i] = 30;
        flag[7] = 1;
      } // All HAAT below 30   are set to 30
      else if (h[i] > 1600) {
        h[i] = 1600;
        flag[8] = 1;
      } // All HAAT above 1600 are set to 1600
    }

    if (curve == 0 || curve == 2) {
      d_first = 1.5;
      d_last = 300.0;
    } else if (curve == 1) {
      d_first = 15.0;
      d_last = 500.0;
    }
    var k = Math.floor(d_first / delta);
    for (i = k; i <= n_points; i++) {
      d[i] = i * delta;
    } // d_first/delta must be an integer

    //continue110:

    if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) {
      if (curve == 0) {
        itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f);
      } else if (curve == 1) {
        itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f);
      } else if (curve == 2) {
        itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
        itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f5010);

        // F(50,90) means field strength at 50% of the locations, 90% of the time
        // Here we can alter the location variability parameter L.  This changes the field strength result.
        // But since in practice, we never use this, it is commented out.
        // It is retained here for reference only.

        // if( L != 50. )
        // {
        //  ZQ = fzq(L);
        //  sigma = 11.88; // > 470 MHz
        //  RL = ZQ * sigma;
      }
    } else if (channel >= 7 && channel <= 13) {
      if (curve == 0) {
        itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f);
      } else if (curve == 1) {
        itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f);
      } else if (curve == 2) {
        itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
        itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f5010);

        // F(50,90) means field strength at 50% of the locations, 90% of the time
        // Here we can alter the location variability parameter L.  This changes the field strength result.
        // But since in practice, we never use this, it is commented out.
        // It is retained here for reference only.

        // if( L != 50. )
        // {
        //  ZQ = fzq(L);
        //  sigma = 11.88; // > 470 MHz
        //  RL = ZQ * sigma;
      }
    } else if (channel >= 14 && channel <= 69) {
      if (curve == 0) {
        itplbv(id50, ih50, D50, H50, F55U, j, d, h, f);
      } else if (curve == 1) {
        itplbv(id10, ih10, D10, H10, F51U, j, d, h, f);
      } else if (curve == 2) {
        itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
        itplbv(id10, ih10, D10, H10, F51U, j, d, h, f5010);

        // F(50,90) means field strength at 50% of the locations, 90% of the time
        // Here we can alter the location variability parameter L.  This changes the field strength result.
        // But since in practice, we never use this, it is commented out.
        // It is retained here for reference only.

        // if( L != 50. )
        // {
        //  ZQ = fzq(L);
        //  sigma = 11.88; // > 470 MHz
        //  RL = ZQ * sigma;
      }
    }

    if (curve == 1 || curve == 2) {
      // add in the 3 to 15 km range to the f field strength array
      // for F(50,10) interfering contours only.  Since the F(50,10) interfering
      // contours start at 15 km, we use the F(50,50) curves in this range.
      var d1 = [];
      var f1 = [];

      for (i = 0; i < 30; i++) f[i] = 0.0;
      for (i = 0; i < n_points; i++) {
        d1[i] = i * delta;
        f1[i] = 0.0;
      }

      if (
        (channel >= 2 && channel <= 6) ||
        (channel >= 200 && channel <= 300)
      ) {
        itplbv(id50, ih50, D50, H50, F55LV, j, d1, h, f1);
      } else if (channel >= 7 && channel <= 13) {
        itplbv(id50, ih50, D50, H50, F55HV, j, d1, h, f1);
      } else if (channel >= 14 && channel <= 69) {
        itplbv(id50, ih50, D50, H50, F55U, j, d1, h, f1);
      }

      //i=i for FM vhf uhf

      for (i = 0; i < 30; i++) {
        if (curve == 1) {
          f[i] = f1[i] * 1.0;
          d[i] = i * delta;
        } else if (curve == 2) {
          f5010[i] = f1[i] * 1.0;
          d[i] = i * delta;
        }
      }

      // TEST  for(i=0; i<35; i++) document.write(f[i] + '  ' + i + '  ' + f1[i] + '  ' + d[i] + '<br>');
    }

    for (
      i = 3;
      i > 0;
      i-- // i = 2,1 0 (3 points) 1.5, 1, 0.5
    ) {
      if (
        (field > f[i] && (curve == 0 || curve == 1)) ||
        (field > f5010[i] && curve == 2)
      ) {
        // High field strength, very close to transmitter site // Service AND Interfering contours.
        // Use the free space equation to find the field strength and distance
        flag[1] = 1;
        e_volts_meter = 1.0e-6 * Math.pow(10, field / 20);
        distance = (7.014271e-3 * Math.sqrt(erp * 1000)) / e_volts_meter;

        // Added 9/2004 to prevent free space distance from exceeding minimum curves distance of
        // 1.5 km (to eliminate the discontinuity between the free space and curves values)

        if (distance >= 1.5) {
          distance = 1.5;
          flag[1] = 0;
        }

        //if(distance < 0.030) { flag[18]=1; distance = 0.030; }  // Use a distance of 0.030 km (roughly 1 second or 100 feet) for mapping, for very small predicted contours
        // Comment this line out for other uses

        if (distance < 0.001) {
          distance = 0.001;
        } // 1 meter distance minimum avoids zero di

        return distance;
      }
    }

    // i=1in next line to avoid overwriting f[0] for very small contours
    for (
      i = 1;
      i < n_points;
      i++ // points i=0,1,2 covered by free space equation immediately above
    ) {
      if (curve == 0 || curve == 1) {
        f[i] = f[i] + erp_db;
      } else if (curve == 2) {
        ZQ = fzq(T); // T is the time variable in F(50,90) = the 90
        RT = (f5010[i] - f5050[i]) * (ZQ / 1.28155);

        f[i] = f5050[i] + RL + RT + erp_db;
      }
    }

    // Most common, for service and interfering contours

    for (
      i = 1;
      i < n_points;
      i++ // start at 1
    ) {
      if (field > f[i] && field < f[i - 1]) {
        distance =
          ((f[i - 1] - field) / (f[i - 1] - f[i])) * (d[i] - d[i - 1]) +
          d[i - 1];

        if (distance > d_last) flag[2] = 1;
        /*  At this point the distance result has been made using the F(50,50) or F(50,10) curves.
                       But if the predicted distance is below 1.5 km, that calculation was extrapolated from the propagation curves.
                       Instead, we should be using the free space equation. 
                       So we re-check to see if we need to recalculate the distance.  The next "if" section, added 2/2/2021, takes care of this.
                   */

        if (distance < 1.5) {
          // then recompute using the free space equation
          flag[1] = 1;
          e_volts_meter = 1.0e-6 * Math.pow(10, field / 20);
          distance = (7.014271e-3 * Math.sqrt(erp * 1000)) / e_volts_meter;
        }

        // Tiny Contour distances will be set to 0.030 km for mapping purposes.
        // This avoids zero contour distances, and allows for a plottable contour polygon.
        // if(distance < 0.030) flag[18]=1;  // Contour distance will be set to 0.030 km for mapping purposes
        // This can be commented out for other purposes

        if (distance < 0.001) distance = 0.001; // 1 meter avoids zero distance.

        return distance;
      }
    }

    // should not get here!
  } // end distance
} // end tvfmfs_metric ----------------------------------------------------------------------------------

function tvfmfs_comment(i) {
  if (i == 0) comment = "";
  else if (i == 1)
    comment =
      "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Free Space equation used to compute distance.<br>\n ";
  else if (i == 2)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered distance exceeds maximum curve distance.<br>\n";
  else if (i == 3)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select a channel range.<br>\n";
  else if (i == 4)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select a contour type.<br>\n";
  else if (i == 5)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select the desired result (Find This).<br>\n";
  else if (i == 6)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERP of less than 0.0001 kW (0.1 watt) is changed to 0.0001 kW for calculations.<br>\n";
  else if (i == 7)
    comment =
      "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered HAAT is less than 30 meters; changed to 30 meters for calculations.<br>\n";
  else if (i == 8)
    comment =
      "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered HAAT is greater than 1600 meters; changed to 1600 meters for calculations.<br>\n";
  else if (i == 9)
    comment =
      "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered Field or Distance is less than zero; set to positive for calculations.<br>\n";
  else if (i == 10)
    comment =
      "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERP exceeds the maximum of 100 kW permitted for U.S. FM stations. <br>\n";
  else if (i == 11)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non-numeric data entered in a form input. <br>\n";
  else if (i == 12)
    comment =
      "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, TV Channels 2-6, is 400 kW. <br>\n";
  else if (i == 13)
    comment =
      "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, TV Channels 7-13, is 400 kW. <br>\n";
  else if (i == 14)
    comment =
      "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for UHF, TV Channels 14-69, is 5500 kW. <br>\n";
  else if (i == 15)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum curve <b>distance</b> for service contours is limited to 300 km. <br>\n";
  else if (i == 16)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum curve <b>distance</b> for interfering contours is limited to 500 km.<br>\n";
  else if (i == 17)
    comment =
      "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 'Find ERP' calculation is not valid for the TV service.<br>\n";
  else comment = "";
  return comment;
}

function fzq(Q) {
  // for F(50,90) curves prediction
  var k;
  var ZGRID = [];

  var ZQ = 0.0; // Initialize

  for (k = 0; k <= 57; k++) {
    ZGRID[k] = -ZGRI[k];
    ZGRID[114 - k] = ZGRI[k];
  }
  for (k = 1; k < 115; k++) {
    if (VGRID[k] < Q) {
    } else {
      ZQ =
        ZGRID[k - 1] +
        ((Q - VGRID[k - 1]) / (VGRID[k] - VGRID[k - 1])) *
          (ZGRID[k] - ZGRID[k - 1]);
      if (ZQ !== ZQ) ZQ = 0.0; // Checking for NaN, set to 0 (means no curve shifts for Q)
      return ZQ;
    }
  }
} // end fzq

function round_power(power_in, error_flag) {
  /************************************************************************
   *
   *     This subroutine will round the power in accordance with the FCC
   *     Rules section 73.212.
   *
   *     POWER_IN   = Unrounded power in Watts or kilowatts; real; input.
   *     POWER_OUT  = Rounded power in Watts or kilowatts; real; output.
   *     ERROR_FLAG = 0; no errors; integer; output.
   *                = 1; Input power is less than minimum allowed,
   *                     POWER_OUT set equal to POWER_IN.
   *                = 2; Input power greater than maximum allowed,
   *                     POWER_OUT set equal to POWER_IN.
   *
   *                     ...kalagian...11/3/86...
   *
   ***********************************************************************/

  var power_out = 0.0;
  var round_factor = 0.0;

  error_flag = 0;
  power_out = power_in + 0.000000000001; // to insure a nonzero power_in

  if (power_in >= 0.001 && power_in < 0.003) {
    round_factor = 0.00005;
  } else if (power_in >= 0.003 && power_in < 0.01) {
    round_factor = 0.0001;
  } else if (power_in >= 0.01 && power_in < 0.03) {
    round_factor = 0.0005;
  } else if (power_in >= 0.03 && power_in < 0.1) {
    round_factor = 0.001;
  } else if (power_in >= 0.1 && power_in < 0.3) {
    round_factor = 0.005;
  } else if (power_in >= 0.3 && power_in < 1.0) {
    round_factor = 0.01;
  } else if (power_in >= 1.0 && power_in < 3.0) {
    round_factor = 0.05;
  } else if (power_in >= 3.0 && power_in < 10) {
    round_factor = 0.1;
  } else if (power_in >= 10.0 && power_in < 30) {
    round_factor = 0.5;
  } else if (power_in >= 30 && power_in < 100) {
    round_factor = 1;
  } else if (power_in >= 100 && power_in < 300) {
    round_factor = 5;
  } else if (power_in >= 300 && power_in < 1000) {
    round_factor = 10.0;
  }

  power_out = power_in / round_factor;
  power_out = Math.floor(Math.round(power_out));
  power_out = power_out * round_factor;

  if (power_in > 1000) {
    power_out = Math.floor(power_in);
  }

  return power_out;
}

/////////////////////////////
// Jose
// functions to calculate terminal points

function calculateTerminalPoint(
  latitudeStart,
  longitudeStart,
  distance,
  azimuth
) {
  const R = 6371; // Earth's radius in kilometers

  // Convert latitude and longitude to radians
  const lat1 = (latitudeStart * Math.PI) / 180;
  const lon1 = (longitudeStart * Math.PI) / 180;
  const brng = (azimuth * Math.PI) / 180;
  const d = distance / R; // Distance in radians

  const lat2 = Math.asin(
    Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(brng)
  );
  const lon2 =
    lon1 +
    Math.atan2(
      Math.sin(brng) * Math.sin(d) * Math.cos(lat1),
      Math.cos(d) - Math.sin(lat1) * Math.sin(lat2)
    );

  // Convert latitude and longitude back to degrees
  const latitudeEnd = (lat2 * 180) / Math.PI;
  const longitudeEnd = (lon2 * 180) / Math.PI;

  return { latitude: latitudeEnd, longitude: longitudeEnd };
}

//////////////////////////////////////////////////////////////////////////
// Jose
// for different xhaat's (corresponding to different radials), get the distances
// for each distance (corresponding to different radials), find the terminal point
// create polygon out of those points

// xcurve:
// 0 - F(50, 50) Service Contour -- FM and NTSC (ananog) TV
// 1 - F(50, 10) Interfering Contour
// 2 - F(50, 90) Digital TV Service Contour

// xchannel:
// 250 - FM Radio or TV Transmit Channels 2-6
// 9 - TV Transmit Channels 7-13
// 20 - TV Transmit Channels 14-69

// xfs_or_dist:
// 1 - Field Strength, given a Distance (in km)
// 2 - Distance, Given a Field Strength (in dBu)
// 3 - FM ERP, given Distance and Field Strength [F(50,50) Service Contour]

// ERP kW
// HAAT meters

// var resulttt = tvfmfs_metric( xerp, xhaat, xchannel, xfield, xdistance, xfs_or_dist, xcurve, xflag);

antennaHeightAMSL = 2329;
avgTerrainAMSL = [
  1840.56, 1836.0, 1833.16, 1826.0, 1823.32, 1819.91, 1816.89, 1813.82, 1813.05,
  1812.72, 1812.77, 1813.31, 1813.89, 1812.18, 1810.11, 1808.54, 1805.56,
  1804.55, 1803.33, 1803.66, 1804.14, 1800.49, 1796.74, 1792.44, 1788.2, 1782.4,
  1777.57, 1771.34, 1765.15, 1759.17, 1751.59, 1743.74, 1736.97, 1730.59,
  1724.38, 1719.49, 1715.48, 1712.79, 1712.21, 1712.47, 1712.54, 1712.34,
  1711.55, 1711.07, 1710.19, 1710.3, 1710.25, 1710.53, 1711.33, 1711.08,
  1712.98, 1711.66, 1707.32, 1703.68, 1701.38, 1699.07, 1696.25, 1693.99,
  1690.91, 1688.52, 1687.01, 1685.75, 1685.14, 1686.44, 1688.59, 1690.29,
  1690.68, 1692.76, 1695.68, 1700.48, 1705.88, 1710.73, 1712.94, 1715.56,
  1716.65, 1718.06, 1719.63, 1720.54, 1717.95, 1713.98, 1710.47, 1708.2,
  1706.31, 1704.38, 1704.19, 1703.11, 1703.78, 1703.67, 1704.16, 1703.62,
  1706.6, 1706.84, 1706.43, 1711.48, 1715.62, 1717.86, 1719.71, 1722.69,
  1726.39, 1729.27, 1731.57, 1733.94, 1737.31, 1740.07, 1743.17, 1747.27,
  1751.89, 1755.78, 1757.92, 1759.98, 1762.33, 1765.68, 1770.47, 1775.41,
  1781.42, 1787.85, 1794.96, 1799.29, 1803.4, 1806.67, 1810.49, 1814.35,
  1817.82, 1818.65, 1820.47, 1818.75, 1816.09, 1816.6, 1812.48, 1806.75,
  1804.32, 1802.15, 1800.19, 1796.57, 1793.14, 1792.22, 1792.99, 1790.8,
  1790.77, 1790.38, 1788.51, 1789.86, 1793.99, 1797.34, 1801.21, 1806.0,
  1809.91, 1812.76, 1818.43, 1820.26, 1822.67, 1828.67, 1838.74, 1857.38,
  1874.27, 1892.54, 1890.22, 1894.0, 1896.53, 1905.68, 1919.35, 1934.54,
  1949.33, 1974.65, 2008.97, 2045.17, 2076.43, 2103.82, 2122.37, 2142.55,
  2149.86, 2169.24, 2169.82, 2151.99, 2149.94, 2144.2, 2149.01, 2159.4, 2163.44,
  2172.42, 2174.18, 2183.92, 2191.54, 2197.74, 2206.39, 2203.64, 2199.73,
  2201.02, 2211.8, 2232.89, 2233.55, 2239.88, 2248.56, 2255.61, 2260.44,
  2266.67, 2272.43, 2284.24, 2290.9, 2290.21, 2288.81, 2288.32, 2279.73,
  2277.67, 2263.57, 2258.37, 2245.27, 2232.17, 2220.76, 2213.86, 2210.27,
  2207.91, 2198.4, 2199.9, 2202.78, 2208.65, 2216.67, 2225.63, 2233.63, 2242.71,
  2251.26, 2254.62, 2255.03, 2261.27, 2270.22, 2283.81, 2295.21, 2285.98,
  2279.04, 2282.52, 2294.62, 2305.75, 2318.04, 2333.36, 2338.08, 2347.29,
  2362.83, 2370.44, 2374.61, 2381.1, 2394.22, 2414.35, 2432.71, 2437.34,
  2429.67, 2420.94, 2414.66, 2406.99, 2399.37, 2393.71, 2384.27, 2369.16,
  2360.81, 2354.99, 2349.81, 2344.62, 2332.13, 2326.46, 2321.08, 2303.22,
  2293.91, 2284.19, 2280.35, 2276.37, 2265.7, 2271.7, 2272.87, 2276.77, 2276.08,
  2272.25, 2256.33, 2216.5, 2188.72, 2181.23, 2160.5, 2154.53, 2163.67, 2178.97,
  2197.43, 2209.03, 2210.49, 2215.92, 2226.97, 2234.64, 2245.89, 2263.65,
  2284.16, 2293.75, 2303.58, 2312.28, 2319.74, 2321.28, 2328.17, 2341.41,
  2356.53, 2375.55, 2405.9, 2431.02, 2439.67, 2432.48, 2426.43, 2422.71,
  2404.84, 2378.17, 2362.36, 2361.99, 2378.32, 2397.96, 2414.26, 2425.62,
  2437.36, 2444.14, 2452.34, 2456.33, 2443.07, 2426.08, 2408.96, 2389.46,
  2372.56, 2371.05, 2370.25, 2358.58, 2357.68, 2329.53, 2303.94, 2288.13,
  2287.49, 2292.26, 2291.84, 2283.37, 2259.39, 2255.61, 2260.03, 2246.56,
  2232.76, 2217.1, 2196.59, 2178.44, 2166.37, 2166.66, 2166.08, 2149.3, 2125.12,
  2104.86, 2091.52, 2062.23, 2039.66, 2028.54, 2029.56, 1995.53, 1961.33,
  1942.28, 1923.06, 1903.87, 1889.54, 1880.18, 1873.04, 1873.31, 1861.99,
  1850.79, 1840.56,
];

const sourceCoordinates = { latitude: 39.7328, longitude: -105.2361 };

// for (i = 0; i < avgTerrainAMSL.length; i++) {
//   haat = antennaHeightAMSL - avgTerrainAMSL[i];
//   distance = tvfmfs_metric("1000", haat, 20, 41, 0, 2, 2, []);
//   // console.log(distance);
//   azimuth = i;
//   terminalPoint = calculateTerminalPoint(
//     sourceCoordinates.latitude,
//     sourceCoordinates.longitude,
//     distance,
//     azimuth
//   );
//   console.log("azimuth:", azimuth);
//   console.log("terminalPoint:", terminalPoint);
// }

module.exports = {
  tvfmfs_metric,
  calculateTerminalPoint,
};
